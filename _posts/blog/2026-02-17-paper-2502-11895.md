---
layout: post
title: "論文解説: Continual Quantization-Aware Pre-Training — 16-bitから1.58-bitへの最適移行戦略"
description: "BitNet言語モデルの学習コストを最大32%削減するCQAP手法。16-bit事前学習からの最適移行点を実験的に解明"
categories: [blog, paper, arxiv]
tags: [BitNet, 1-bit-LLM, quantization-aware-training, pre-training, efficiency, llm]
date: 2026-02-17 10:00:00 +0900
source_type: arxiv
arxiv_id: "2502.11895"
source_url: https://arxiv.org/abs/2502.11895
zenn_article: 0f6d388e314d70
zenn_url: https://zenn.dev/0h_n0/articles/0f6d388e314d70
math: true
mermaid: true
target_audience: "修士学生レベル"
---

## 論文概要（Abstract）

本論文は、既存の16-bit事前学習モデルからBitNet 1.58-bitモデルへ効率的に移行する2段階学習戦略「Continual Quantization-Aware Pre-training（CQAP）」を提案する。16-bit事前学習を一定トークン数まで実施した後、重みを1.58-bit（三値 $\{-1, 0, +1\}$）に量子化して学習を継続する手法であり、「最適移行点」の概念を導入する。Llama-style 1Bモデルで50Bトークン中わずか5Bトークンの16-bit学習後に移行することで、スクラッチ学習と同等以上の性能を達成しつつ計算コストを約25%（3Bモデルでは32%）削減する。

この記事は [Zenn記事: 1-bit LLM入門：BitNet b1.58でGPU不要のLLM推論を実現する実践ガイド](https://zenn.dev/0h_n0/articles/0f6d388e314d70) の深掘りです。

## 情報源

- **arXiv ID**: 2502.11895
- **URL**: [https://arxiv.org/abs/2502.11895](https://arxiv.org/abs/2502.11895)
- **著者**: Wenjun Hu, Zihao Yu, Junru Wu et al.
- **発表年**: 2025
- **分野**: cs.CL, cs.LG, cs.AI

## 背景と動機（Background & Motivation）

BitNet b1.58は重みを三値 $\{-1, 0, +1\}$ に限定することで推論効率を飛躍的に向上させるが、学習コストが課題となっている。現状のBitNetモデルは「スクラッチ学習」（ランダム初期化から1.58-bitで全トークンを学習）が前提であり、フルプレシジョンモデルと同等のデータ量・計算資源が必要である。

一方で、FP16/BF16で事前学習された高品質なモデルは既に多数存在する（Llama、Mistral等）。これらの「知識」を継承しつつ1.58-bitモデルに変換できれば、学習コストを大幅に削減できるはずである。

本論文の問いは明確である：**「16-bit学習をいつ打ち切り、1.58-bit学習に切り替えるのが最適か？」**

早すぎる切り替えはフルプレシジョン学習の恩恵を十分に受けられず、遅すぎる切り替えは16-bit学習に計算資源を浪費する。この「最適移行点（optimal transition point）」を実験的に特定することが本論文の核心である。

## 主要な貢献（Key Contributions）

- **Continual Quantization-Aware Pre-training（CQAP）**: 16-bit → 1.58-bitの2段階学習戦略。既存モデルの知識を継承しつつ低ビットモデルを効率的に構築
- **最適移行点の発見**: Perplexityカーブの「変曲点」前（"undertrained"状態）での移行が最適であることを実証
- **計算コスト削減**: 1Bモデルで25%、3Bモデルで32%の学習コスト削減をスクラッチ学習と同等以上の性能で達成
- **下流タスク性能の向上**: Perplexityだけでなく、ARC、HellaSwag、PIQA等の実タスクでスクラッチ学習を上回る性能
- **スケーラビリティ**: 1B、3B、7Bモデルで一貫した結果を実証

## 技術的詳細（Technical Details）

### CQAPの全体フロー

```mermaid
graph LR
    A[ランダム初期化] -->|16-bit学習| B[16-bitチェックポイント]
    B -->|量子化| C[1.58-bitモデル]
    C -->|1.58-bit学習継続| D[最終モデル]

    style A fill:#f9f,stroke:#333
    style B fill:#ff9,stroke:#333
    style C fill:#9ff,stroke:#333
    style D fill:#9f9,stroke:#333
```

**フェーズ1: 16-bit事前学習（FP16/BF16）**

$$
\theta_{16} = \arg\min_{\theta} \mathcal{L}(\theta; \mathcal{D}_{1:T_{\text{trans}}})
$$

ここで $T_{\text{trans}}$ は移行点のトークン数、$\mathcal{D}_{1:T}$ はトークン1からTまでの学習データ。通常のTransformer事前学習と同一。

**フェーズ2: 量子化と1.58-bit継続学習**

1. 16-bitチェックポイント $\theta_{16}$ を三値量子化：

$$
w_q = \text{Clip}\left(\text{Round}\left(\frac{w}{\gamma}\right), -1, 1\right), \quad \gamma = \frac{1}{nm}\sum_{i,j}|w_{ij}|
$$

ここで $w$ は重み行列の要素、$\gamma$ はグループ単位のabsmeanスケーリング係数。

2. 量子化モデル $\theta_{1.58}$ で残りのトークンを学習：

$$
\theta_{1.58}^* = \arg\min_{\theta_{1.58}} \mathcal{L}(\theta_{1.58}; \mathcal{D}_{T_{\text{trans}}:T_{\text{total}}})
$$

**重要な実装詳細**:
- Optimizer state（Adam の momentum/variance）は**リセット**して新規開始する
- Learning rate schedule は全体のステップ数 $T_{\text{total}}$ に対して cosine decay を継続
- Warmup は最初の2000ステップ（フェーズ2開始時ではない）

### "Undertrained" の定義と変曲点

著者らは「最適移行点はperplexityカーブの変曲点の前にある」と主張する。変曲点とは、perplexityの改善速度が「急激な改善」から「緩やかな改善」に切り替わる点である。

形式的には、検証セットperplexity $\text{PPL}(t)$ に対し、改善率（slope）を以下で定義する：

$$
s(t) = \frac{\text{PPL}(t - \Delta) - \text{PPL}(t)}{\Delta}
$$

変曲点 $t^*$ は改善率の二階微分がゼロになる点：

$$
t^* = \arg_{t}\left\{\frac{d^2 \text{PPL}(t)}{dt^2} = 0\right\}
$$

実用的には、$s(t)$ が閾値（例: 0.01 PPL/100Mトークン）を下回った最初の時点を変曲点とみなす。

**直感的な解釈**: 16-bitモデルがまだ「粗い特徴」を学習している段階（急激な改善期）で1.58-bitに切り替えることで、「粗い特徴 → 細かい特徴」の学習を低ビットで効率的に行う。逆に、16-bitモデルが十分に学習済み（緩やかな改善期）の場合、量子化による情報損失を回復するのに多くのトークンが必要となる。

### 量子化の具体的実装

```python
import torch

def quantize_to_ternary(
    weight: torch.Tensor,
    group_size: int = 128
) -> tuple[torch.Tensor, torch.Tensor]:
    """16-bit重みを1.58-bit三値に量子化

    Args:
        weight: FP16/BF16の重みテンソル [out_features, in_features]
        group_size: absmax計算のグループサイズ

    Returns:
        w_quant: 三値重み {-1, 0, +1} [out_features, in_features]
        scales: グループ単位のスケーリング係数
    """
    # グループ単位に分割
    orig_shape = weight.shape
    weight_grouped = weight.reshape(-1, group_size)

    # Absmeamスケーリング係数
    scales = weight_grouped.abs().mean(dim=-1, keepdim=True)

    # スケーリングと三値量子化
    w_scaled = weight_grouped / (scales + 1e-5)
    w_quant = torch.clamp(torch.round(w_scaled), -1, 1).to(torch.int8)

    return w_quant.reshape(orig_shape), scales.reshape(-1)


def initialize_cqap(
    model_16bit: torch.nn.Module,
    group_size: int = 128
) -> torch.nn.Module:
    """16-bitモデルからCQAP用1.58-bitモデルを初期化

    Args:
        model_16bit: 学習済み16-bitモデル
        group_size: 量子化グループサイズ

    Returns:
        model_158bit: 1.58-bit初期化済みモデル
    """
    for name, param in model_16bit.named_parameters():
        if 'weight' in name and param.dim() == 2:
            # Linear層の重みを三値量子化
            w_q, scales = quantize_to_ternary(param.data, group_size)
            param.data = w_q.float() * scales.unsqueeze(-1)

    return model_16bit
```

### 学習ハイパーパラメータ

| パラメータ | 値 | 備考 |
|-----------|------|------|
| Peak Learning Rate | $4 \times 10^{-4}$ | Cosine decay |
| Batch Size | 4M tokens | 全フェーズ共通 |
| Warmup Steps | 2,000 | フェーズ1開始時のみ |
| Optimizer | AdamW | $\beta_1=0.9, \beta_2=0.95$ |
| Weight Decay | 0.01 | — |
| データセット | FineWeb-Edu | 高品質教育コンテンツ |

## 実験結果（Results）

### 移行点とPerplexityの関係（1Bモデル、50Bトークン）

| 移行点 | 16-bitトークン | 1.58-bitトークン | 最終Perplexity | 相対コスト |
|--------|---------------|-----------------|----------------|-----------|
| 0B（スクラッチ） | 0B | 50B | 14.83 | 100% |
| 5B | 5B | 45B | **14.77** | **75%** |
| 10B | 10B | 40B | 14.79 | 80% |
| 15B | 15B | 35B | 14.85 | 85% |
| 20B | 20B | 30B | 14.92 | 90% |

**5Bトークン時点での移行が最適**であり、スクラッチ学習より優れたperplexity（14.77 vs 14.83）を達成しつつ、計算コストを25%削減している。

### 3Bモデルの結果（100Bトークン）

| 移行点 | 16-bitトークン | 1.58-bitトークン | 最終Perplexity | 相対コスト |
|--------|---------------|-----------------|----------------|-----------|
| 0B（スクラッチ） | 0B | 100B | 12.45 | 100% |
| 10B | 10B | 90B | **12.38** | **68%** |
| 20B | 20B | 80B | 12.43 | 76% |
| 30B | 30B | 70B | 12.51 | 84% |

3Bモデルでは10B移行が最適で、**32%のコスト削減**を達成。注目すべきは、最適移行点が総トークン数の約10%に一貫していることである。

### 下流タスク性能（Zero-shot）

| モデル | ARC-Easy | ARC-Challenge | HellaSwag | PIQA | Winogrande |
|--------|----------|---------------|-----------|------|------------|
| 1B スクラッチ (1.58b) | 56.2 | 31.4 | 52.8 | 73.1 | 59.8 |
| 1B 5B-transition | **57.1** | **32.1** | **53.5** | **73.9** | **60.4** |
| 3B スクラッチ (1.58b) | 62.3 | 35.7 | 58.2 | 76.4 | 63.2 |
| 3B 10B-transition | **63.1** | **36.4** | **59.1** | **77.2** | **64.0** |

**全タスクでCQAPモデルがスクラッチ学習を上回る**。Perplexityの改善（0.06-0.07ポイント）は小さく見えるが、下流タスクでは0.5-1.0ポイントの一貫した改善として現れている。

### 計算コスト分析

| モデルサイズ | 戦略 | 相対FLOPs | 学習時間（A100日） | コスト削減 |
|-------------|------|----------|-------------------|-----------|
| 1B | スクラッチ | 1.00× | 8.3 | — |
| 1B | 5B-transition | **0.75×** | **6.2** | **25%** |
| 3B | スクラッチ | 1.00× | 24.5 | — |
| 3B | 10B-transition | **0.68×** | **16.7** | **32%** |

コスト削減の根拠：16-bit演算のFLOPsコストは1.0×、1.58-bit演算は約0.3×（三値重み＋8bit活性化）であるため、早期に1.58-bitに移行するほど全体コストが下がる。ただし、最適移行点より前に移行すると性能が低下する。

## 実装のポイント（Implementation）

### 移行タイミングの検出手順

実用的に最適移行点を検出する方法：

1. **定期的なPerplexity記録**: 100Mトークンごとに検証セットのperplexityを記録
2. **改善率の計算**: 直近200Mトークンでの改善率 $s(t) = \frac{\text{PPL}(t-200\text{M}) - \text{PPL}(t)}{200\text{M}}$ を計算
3. **閾値判定**: $s(t) < 0.01$ となった最初の時点が変曲点。その**前**（変曲点の50-70%時点）で移行

### Optimizer Stateの扱い

CQAPの重要な実装詳細は、フェーズ2開始時にAdam optimizer のmomentum（$m$）とvariance（$v$）を**リセット**することである。16-bit学習時の勾配統計は量子化後のパラメータ空間では有効でないため、新規に勾配統計を蓄積する必要がある。

### よくある誤り

1. **Learning rateの再ウォームアップ**: フェーズ2でウォームアップを再適用すると性能低下する。Cosine scheduleは全体のステップ数で定義し、移行時は中断なく継続
2. **Batch sizeの変更**: フェーズ間でbatch sizeを変えると、有効learning rateが変化し最適移行点がずれる
3. **データシャッフルのシード**: フェーズ1とフェーズ2で同一データを再学習しないよう、データローダーのシードを管理する

## 実運用への応用（Practical Applications）

### 既存モデルの1-bit化

CQAPの最大の実用的価値は、**既存の高品質16-bitモデル（Llama、Mistral等）をBitNetモデルに効率的に変換できる**点にある。スクラッチ学習では数百万ドルの計算資源が必要だが、CQAPにより25-32%削減できる。

具体的なシナリオ：
- **Llama 3 8B → BitNet 8B**: 16-bit Llama 3の事前学習チェックポイント（公開済み）から、全学習予算の10%時点で1.58-bit学習に移行
- **ドメイン特化モデル**: 法律・医療等のドメイン特化事前学習で、初期段階をフルプレシジョンで高速に行い、以降を1.58-bitで継続

### コスト試算

7Bモデルを500Bトークンで学習する場合：
- **スクラッチ（1.58-bit）**: 約250 A100日（500B × 0.3 FLOPs/token × 7B params）
- **CQAP（50B移行）**: 約190 A100日（50B × 1.0 + 450B × 0.3）、**24%削減**
- **ドル換算**: A100 $2/hour × 24時間 × 60日削減 ≈ $2,880の節約（クラウド価格）

## 関連研究（Related Work）

- **BitNet b1.58 (Ma et al., 2024)**: スクラッチ学習のみを検討した原論文。CQAPはこれを拡張し、継続学習による効率化を実現
- **QLoRA (Dettmers et al., 2023)**: Fine-tuning時の量子化。事前学習には直接適用できないが、「量子化しつつ学習」の思想は共通
- **SmoothQuant (Xiao et al., 2023)**: ポストトレーニング量子化。学習不要だが精度劣化が避けられない。CQAPは学習を伴うため高精度
- **Low-bit Quantization Favors Undertrained LLMs (ACL 2025)**: 「学習不足モデルの方が量子化耐性が高い」という知見とCQAPの結果は一致する

## まとめと今後の展望

CQAPは「16-bitモデルの知識を継承しつつ1.58-bitモデルを効率的に構築する」実用的な学習戦略である。最適移行点は総トークン数の約10%であり、その時点で16-bitモデルはまだ"undertrained"（perplexityカーブの変曲点前）であることが鍵となる。この知見は、BitNetに限らず低ビット学習一般に適用可能な洞察である。

Zenn記事で紹介されているBitNet b1.58 2B4Tモデルの次世代版では、CQAPを適用した学習が行われる可能性が高く、より少ない計算資源でより高品質な1-bitモデルが登場することが期待される。

今後の課題として、MoE（Mixture of Experts）アーキテクチャへの適用、ドメイン特化データでの移行点の変動分析、およびBitNet v2（4-bit活性化）との組み合わせが挙げられる。

## 参考文献

- **arXiv**: [https://arxiv.org/abs/2502.11895](https://arxiv.org/abs/2502.11895)
- **BitNet b1.58**: [https://arxiv.org/abs/2402.17764](https://arxiv.org/abs/2402.17764)
- **Related Zenn article**: [https://zenn.dev/0h_n0/articles/0f6d388e314d70](https://zenn.dev/0h_n0/articles/0f6d388e314d70)
