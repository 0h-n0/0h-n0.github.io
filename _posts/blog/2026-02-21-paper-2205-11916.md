---
layout: post
title: "論文解説: Large Language Models are Zero-Shot Reasoners"
description: "「Let's think step by step」の一文追加でLLMの推論能力を引き出すZero-shot CoTの原論文を詳細解説"
categories: [blog, paper, arxiv]
tags: [prompt-engineering, zero-shot, chain-of-thought, LLM, reasoning]
date: 2026-02-21 13:00:00 +0900
source_type: arxiv
arxiv_id: "2205.11916"
source_url: https://arxiv.org/abs/2205.11916
zenn_article: 8d05ea9be7e0f3
zenn_url: https://zenn.dev/0h_n0/articles/8d05ea9be7e0f3
math: true
mermaid: true
target_audience: "修士学生レベル"
---

## 論文概要（Abstract）

「Large Language Models are Zero-Shot Reasoners」は、LLMがタスク固有の例示なしでも推論能力を発揮できることを示した画期的な研究です。Kojima et al.（2022, 東京大学）は、プロンプトに「Let's think step by step」（ステップバイステップで考えよう）の一文を追加するだけで、MultiArithベンチマークの正答率が17.7%から78.7%に向上することを実証しました（InstructGPT使用時）。この手法はZero-shot CoT（Zero-shot Chain of Thought）と名付けられ、例示作成コストゼロでCoTの恩恵を得られる手法として広く普及しました。NeurIPS 2022に採択されています。

この記事は [Zenn記事: 2026年版プロンプトテクニック大全：8手法の使い分けとコンテキスト設計](https://zenn.dev/0h_n0/articles/8d05ea9be7e0f3) の深掘りです。

## 情報源

- **arXiv ID**: 2205.11916
- **URL**: [https://arxiv.org/abs/2205.11916](https://arxiv.org/abs/2205.11916)
- **著者**: Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, Yusuke Iwasawa
- **発表年**: 2022（NeurIPS 2022採択）
- **分野**: cs.CL, cs.AI, cs.LG

## 背景と動機（Background & Motivation）

Wei et al.（2022）のChain-of-Thought Promptingは推論性能を飛躍的に向上させましたが、タスクごとに人間が推論ステップの例示を手作りする必要がありました。例えば算術推論には算術の例示、常識推論には常識の例示と、タスクに応じた高品質な例示の準備が実務上のボトルネックでした。

Kojima et al.はこの問題に対して、「LLMの中に潜在的な推論能力が既に存在しており、適切なプロンプトで引き出せるのではないか」という仮説を立てました。Few-shotの例示がなくても、「考えてから答えて」と指示するだけでモデルが推論ステップを自発的に生成する可能性を検証しました。

この研究は、LLMの「untapped and understudied fundamental zero-shot capabilities」（未開拓で未研究の基本的なゼロショット能力）を明らかにするものであり、プロンプトエンジニアリングの敷居を大幅に下げる貢献を果たしました。

## 主要な貢献（Key Contributions）

- **貢献1**: 「Let's think step by step」という単一のプロンプトテンプレートで、タスク固有の例示なしにLLMの推論能力を大幅に引き出すZero-shot CoT手法を提案
- **貢献2**: 算術推論（MultiArith +61%、GSM8K +30.3%）、記号推論（Last Letter +13%）、論理推論（Date Understanding +15.4%）の多領域で有効性を実証
- **貢献3**: Zero-shot CoTの2段階プロセス（推論生成→回答抽出）を形式化し、様々なトリガーフレーズ（「Let's think step by step」「Let's think about this logically」等）の効果を比較分析

## 技術的詳細（Technical Details）

### Zero-shot CoTの2段階プロセス

Zero-shot CoTは、1回のプロンプトではなく2段階のプロンプティングで構成されます。

**ステージ1: 推論の生成（Reasoning Extraction）**

入力 $x$ に対して、トリガーフレーズ $t$ を連結してモデルに推論ステップを生成させます。

$$
r = \text{LLM}(x \oplus t)
$$

ここで、
- $x$: 元の質問文
- $t$: トリガーフレーズ（例: 「Let's think step by step」）
- $\oplus$: テキスト連結
- $r$: 生成された推論テキスト（推論ステップ＋回答を含む可能性）

**ステージ2: 回答の抽出（Answer Extraction）**

ステージ1で生成された推論テキスト $r$ から最終回答を抽出します。

$$
a = \text{LLM}(x \oplus t \oplus r \oplus t')
$$

ここで $t'$ は回答抽出プロンプト（例: 「Therefore, the answer (arabic numerals) is」）です。

この2段階構成が重要な理由は、ステージ1で生成されるテキストには推論ステップと回答が混在しており、最終回答の明確な抽出が必要だからです。

### 数学的解釈

Zero-shot CoTは、Few-shot CoTの例示集合 $\{(x_i, c_i, y_i)\}_{i=1}^k$ を空集合 $\emptyset$ とし、トリガーフレーズ $t$ で例示の役割を代替するものと解釈できます。

$$
p_{\text{Zero-shot CoT}}(y \mid x) = \sum_r p(y \mid r, x, t) \cdot p(r \mid x, t)
$$

$$
p_{\text{Few-shot CoT}}(y \mid x) = \sum_c p(y \mid c, x, \mathcal{E}) \cdot p(c \mid x, \mathcal{E})
$$

ここで $\mathcal{E} = \{(x_i, c_i, y_i)\}_{i=1}^k$ はFew-shot例示集合です。

Zero-shot CoTでは $\mathcal{E}$ が不要なため、新しいタスクへの適用コストが大幅に低下します。

### トリガーフレーズの比較

論文では複数のトリガーフレーズを比較しています（InstructGPT, MultiArithベンチマーク）。

| トリガーフレーズ | 精度 |
|----------------|------|
| 「Let's think step by step」 | **78.7%** |
| 「Let's think about this logically」 | 74.5% |
| 「Let's solve this problem by splitting it into steps」 | 72.2% |
| 「Let's be realistic and think step by step」 | 57.5% |
| 「Let's think like a detective step by step」 | 70.3% |
| （トリガーなし = Zero-shot） | 17.7% |
| 「Let's think step by step」（日本語: 「ステップバイステップで考えましょう」） | 類似の効果 |

「Let's think step by step」が最も効果的であり、これが事実上の標準フレーズとして定着しました。

### アルゴリズムの実装

```python
from openai import OpenAI

def zero_shot_cot(
    question: str,
    trigger: str = "Let's think step by step.",
    model: str = "gpt-4"
) -> dict[str, str]:
    """Zero-shot Chain-of-Thought の2段階実装

    Args:
        question: 解きたい問題文
        trigger: 推論を誘発するトリガーフレーズ
        model: 使用するモデルID

    Returns:
        {"reasoning": 推論テキスト, "answer": 最終回答}
    """
    client = OpenAI()

    # ステージ1: 推論の生成
    stage1_prompt = f"Q: {question}\nA: {trigger}"

    stage1_response = client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": stage1_prompt}],
        temperature=0,
        max_tokens=1024
    )
    reasoning = stage1_response.choices[0].message.content

    # ステージ2: 回答の抽出
    stage2_prompt = (
        f"Q: {question}\n"
        f"A: {trigger}\n"
        f"{reasoning}\n"
        f"Therefore, the answer is"
    )

    stage2_response = client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": stage2_prompt}],
        temperature=0,
        max_tokens=64
    )
    answer = stage2_response.choices[0].message.content.strip()

    return {"reasoning": reasoning, "answer": answer}


# 使用例
result = zero_shot_cot(
    "ジョンは3個のリンゴを持っています。友達から2個もらい、"
    "その後1個を妹にあげました。ジョンは今何個持っていますか？"
)
print(f"推論: {result['reasoning']}")
print(f"回答: {result['answer']}")
```

### モダンな1ステージ実装

2026年現在のモデル（GPT-4, Claude 3.5以降）では、2段階に分けなくても1回のプロンプトで推論と回答の両方を適切に生成できるようになっています。

```python
def zero_shot_cot_modern(
    question: str,
    model: str = "gpt-4"
) -> str:
    """モダンなZero-shot CoT（1ステージ版）

    最新モデルでは2段階に分ける必要がなく、
    システムプロンプトにトリガーを含めるだけで十分
    """
    client = OpenAI()

    response = client.chat.completions.create(
        model=model,
        messages=[
            {
                "role": "system",
                "content": (
                    "問題を解く際は、まず段階的に考えてから"
                    "最終回答を提示してください。"
                )
            },
            {"role": "user", "content": question}
        ],
        temperature=0
    )

    return response.choices[0].message.content
```

### モデルサイズとZero-shot CoTの関係

Few-shot CoTと同様に、Zero-shot CoTもモデルサイズに依存する創発的能力です。

| モデル | パラメータ | MultiArith精度 (Zero-shot) | MultiArith精度 (Zero-shot CoT) |
|--------|-----------|--------------------------|-------------------------------|
| GPT-2 | 1.5B | 2.5% | 3.1% |
| GPT-Neo | 2.7B | 4.2% | 5.7% |
| GPT-J | 6B | 8.1% | 12.3% |
| InstructGPT | 175B | 17.7% | **78.7%** |
| PaLM | 540B | 25.5% | **66.1%** |

100B以下のモデルではZero-shot CoTの効果は限定的です。175B以上で劇的な効果が現れ、「ステップバイステップで考えよう」という指示を理解し実行する能力がモデルスケールの臨界点を超えて創発することが示唆されます。

## 実装のポイント（Implementation）

### Zero-shot CoTの適用判断フロー

Zero-shot CoTは万能ではありません。以下の判断フローで適用を決定します。

1. **まずZero-shot（トリガーなし）を試す**: 精度が十分なら追加テクニック不要
2. **精度不足ならZero-shot CoTを試す**: 「Let's think step by step」を追加
3. **それでも不十分ならFew-shot CoTへ**: タスク固有の例示を追加
4. **さらに精度が必要ならSelf-Consistency**: 複数サンプル＋多数決

このステップアップアプローチは、コストを最小化しながら必要な精度を達成する実務的なベストプラクティスです。

### 言語別のトリガーフレーズ

日本語環境での推奨トリガーフレーズ:

```python
TRIGGERS = {
    "en": "Let's think step by step.",
    "ja": "ステップバイステップで考えましょう。",
    "ja_alt": "段階的に考えてみましょう。",
    "zh": "让我们一步一步地思考。",
}
```

日本語環境でも英語のトリガーが効果的な場合が多いです。これはLLMの事前学習データに英語が多く含まれるためです。タスクの言語とトリガーの言語を分離してテストすることを推奨します。

### よくあるバグ・落とし穴

- **2段階を1回にまとめてしまう**: 旧世代モデルでは2段階が必須。最新モデル（GPT-4, Claude 3.5以降）では1段階で十分
- **回答抽出の失敗**: ステージ2で回答が抽出できない場合のフォールバック処理が必要
- **不適切なタスクへの適用**: 単純な分類（感情分析等）にCoTを適用すると、不要な推論ステップがかえって精度を下げる場合がある
- **トリガーフレーズの過信**: 「Let's think step by step」が常に最適とは限らない。タスクに応じてフレーズをテストすべき

```python
def zero_shot_cot_with_fallback(
    question: str,
    model: str = "gpt-4"
) -> str:
    """フォールバック付きZero-shot CoT

    推論ステップの生成に失敗した場合、
    通常のZero-shotにフォールバック
    """
    # まずZero-shot CoTを試行
    result = zero_shot_cot_modern(question, model)

    # 推論ステップが含まれているか検証
    reasoning_indicators = [
        "ステップ", "まず", "次に", "したがって",
        "step", "first", "then", "therefore"
    ]
    has_reasoning = any(
        indicator in result.lower()
        for indicator in reasoning_indicators
    )

    if not has_reasoning:
        # フォールバック: 明示的に推論を要求
        client = OpenAI()
        response = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": "必ず推論過程を示してから回答してください。"},
                {"role": "user", "content": f"{question}\n\nLet's think step by step."}
            ],
            temperature=0
        )
        result = response.choices[0].message.content

    return result
```

## Production Deployment Guide

### AWS実装パターン（コスト最適化重視）

Zero-shot CoTはFew-shot CoTと比較して入力トークン数が少ない（例示が不要）ため、コスト面で優位です。

**トラフィック量別の推奨構成**:

| 規模 | 月間リクエスト | 推奨構成 | 月額コスト | 主要サービス |
|------|--------------|---------|-----------|------------|
| **Small** | ~3,000 (100/日) | Serverless | $30-100 | Lambda + Bedrock + DynamoDB |
| **Medium** | ~30,000 (1,000/日) | Hybrid | $200-600 | Lambda + ECS Fargate + ElastiCache |
| **Large** | 300,000+ (10,000/日) | Container | $1,500-4,000 | EKS + Karpenter + EC2 Spot |

※ Few-shot CoTと比較して入力トークンが少ない分、約30-50%のコスト削減

**コスト削減テクニック**:
- Zero-shot CoTはFew-shot例示が不要なため、入力トークン数が大幅に少ない
- システムプロンプトにトリガーを含め、Prompt Cachingで固定化（30-90%削減）
- 簡単なタスクはCoT不要 → 難易度判定ルーティングで振り分け
- Bedrock Batch APIで非リアルタイム処理は50%割引

**コスト試算の注意事項**: 上記は2026年2月時点のAWS ap-northeast-1（東京）リージョン料金に基づく概算値です。Zero-shot CoTは出力トークンが増加するため、出力料金にも注意が必要です。最新料金は[AWS料金計算ツール](https://calculator.aws/)で確認してください。

### Terraformインフラコード

```hcl
resource "aws_lambda_function" "zs_cot_handler" {
  filename      = "lambda.zip"
  function_name = "zero-shot-cot-handler"
  role          = aws_iam_role.lambda_zscot.arn
  handler       = "index.handler"
  runtime       = "python3.12"
  timeout       = 60
  memory_size   = 512
  environment {
    variables = {
      BEDROCK_MODEL_ID    = "anthropic.claude-3-5-haiku-20241022-v1:0"
      DYNAMODB_TABLE      = aws_dynamodb_table.zscot_cache.name
      COT_TRIGGER         = "Let's think step by step."
      ENABLE_FALLBACK     = "true"
    }
  }
}

resource "aws_dynamodb_table" "zscot_cache" {
  name         = "zero-shot-cot-cache"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "question_hash"
  attribute { name = "question_hash"; type = "S" }
  ttl { attribute_name = "expire_at"; enabled = true }
}
```

### コスト最適化チェックリスト

- [ ] Zero-shot CoTによるFew-shot例示の削減（入力トークン30-50%減）
- [ ] システムプロンプトのPrompt Caching有効化
- [ ] 難易度判定ルーティング（単純タスクはCoT不要で直接回答）
- [ ] 結果キャッシュ（DynamoDB TTL付き、同一質問の再計算回避）
- [ ] Bedrock Batch API（非リアルタイム処理で50%割引）
- [ ] Spot Instances優先（EKS + Karpenter自動管理）
- [ ] Lambda メモリ512MB（Zero-shot CoTは軽量処理）
- [ ] AWS Budgets設定（月額予算の80%で警告）
- [ ] CloudWatchアラーム（出力トークン量の監視）
- [ ] Cost Anomaly Detection有効化

## 実験結果（Results）

### 主要ベンチマーク（InstructGPT 175B使用）

| ベンチマーク | タスク分類 | Zero-shot | Zero-shot CoT | 改善幅 |
|------------|----------|-----------|--------------|--------|
| MultiArith | 算術推論 | 17.7% | **78.7%** | +61.0% |
| GSM8K | 算術推論 | 10.4% | **40.7%** | +30.3% |
| SVAMP | 算術推論 | 63.7% | **79.3%** | +15.6% |
| AQuA | 代数推論 | 22.4% | **33.5%** | +11.1% |
| Last Letter | 記号推論 | 0.2% | **13.2%** | +13.0% |
| Coin Flip | 記号推論 | 49.2% | **65.8%** | +16.6% |
| Date Understanding | 論理推論 | 49.3% | **64.7%** | +15.4% |

### Few-shot CoTとの比較

| 手法 | MultiArith | GSM8K | 例示作成コスト |
|------|-----------|-------|--------------|
| Zero-shot | 17.7% | 10.4% | なし |
| **Zero-shot CoT** | **78.7%** | **40.7%** | **なし** |
| Few-shot CoT (8-shot) | 83.8% | 56.5% | 高い |

Zero-shot CoTはFew-shot CoTの約90-95%の性能を、例示作成コストゼロで達成しています。この5-10%の精度差を許容できるユースケースでは、Zero-shot CoTが圧倒的にコスト効率が良い選択です。

### タスクカテゴリ別の効果

| カテゴリ | 平均改善幅 | 効果 |
|---------|----------|------|
| 算術推論 | +29.5% | 最大 |
| 記号推論 | +14.8% | 大 |
| 論理推論 | +15.4% | 大 |
| 常識推論 | +3.2% | 中 |
| 自然言語理解 | +1.5% | 小 |

算術推論で最大の効果があり、自然言語理解（感情分析等）では効果が限定的です。これは、推論ステップが必要なタスクほどCoTの恩恵が大きいことを示唆しています。

## 実運用への応用（Practical Applications）

Zero-shot CoTは以下の場面で特に有効です。

**プロトタイピング**: 新しいタスクの初期検証で、例示を作成する前にZero-shot CoTで精度を確認。十分な精度が得られればFew-shotに進む必要がありません。

**多言語対応**: 例示の翻訳コストが不要なため、多言語タスクでのスケーリングが容易です。トリガーフレーズのみを翻訳（または英語のまま使用）すれば複数言語に対応可能です。

**コスト制約の厳しい環境**: Few-shot例示によるトークン消費を回避できるため、高頻度のAPIコールでも入力コストを抑えられます。$N=8$のFew-shotと比較して入力トークンが約70-80%削減されるケースが多いです。

## 関連研究（Related Work）

- **Chain-of-Thought Prompting (Wei et al., 2022)**: Few-shot CoTの原論文。例示付きCoTで最高精度を達成するが、例示作成コストが発生
- **Auto-CoT (Zhang et al., 2023)**: CoT例示の自動生成手法。Zero-shot CoTとFew-shot CoTの中間に位置し、例示作成コストを自動化で削減
- **Plan-and-Solve Prompting (Wang et al., 2023)**: 「Let's first understand the problem and devise a plan」という拡張トリガーでZero-shot CoTを改善。計画ステップの明示化によりステップ欠落エラーを低減

## まとめと今後の展望

Kojima et al.のZero-shot CoTは、プロンプトエンジニアリングの民主化に貢献した重要な研究です。「Let's think step by step」という一文の追加だけでLLMの潜在的な推論能力を引き出せるという発見は、例示作成の専門知識がなくてもCoTの恩恵を享受できることを意味します。

2026年現在、最新のLLM（GPT-4, Claude 3.5 Sonnet以降）では推論能力がさらに向上しており、多くのケースでZero-shot CoTが最初の選択肢として推奨されます。精度不足の場合のみFew-shot CoT→Self-Consistencyとステップアップする段階的アプローチが、コスト効率の面で最適です。

## 参考文献

- **arXiv**: [https://arxiv.org/abs/2205.11916](https://arxiv.org/abs/2205.11916)
- **NeurIPS 2022**: [https://nips.cc/Conferences/2022](https://nips.cc/Conferences/2022)
- **Related Zenn article**: [https://zenn.dev/0h_n0/articles/8d05ea9be7e0f3](https://zenn.dev/0h_n0/articles/8d05ea9be7e0f3)
