---
layout: post
title: "論文解説: An Analysis of Fusion Functions for Hybrid Retrieval — RRF vs 線形結合 vs Learning to Rank の体系的比較"
description: "ハイブリッド検索の融合関数（RRF・線形結合・LTR）をMS MARCO・BEIR・Robust04で体系的に比較し、実務での使い分け指針を導出した論文の詳細解説"
categories: [blog, paper, arxiv]
tags: [hybrid-search, RRF, BM25, dense-retrieval, BEIR, information-retrieval, rag, search]
date: 2026-02-20 09:00:00 +0900
source_type: arxiv
arxiv_id: "2210.11934"
source_url: https://arxiv.org/abs/2210.11934
zenn_article: f3d8b80351ae7b
zenn_url: https://zenn.dev/0h_n0/articles/f3d8b80351ae7b
math: true
mermaid: true
target_audience: "修士学生レベル"
---

## 論文概要（Abstract）

本論文は、ハイブリッド検索における**融合関数（Fusion Functions）**を体系的に比較した研究です。スパース検索（BM25, SPLADE）とデンス検索（DPR, TAS-B, ColBERT v2）を組み合わせる際の融合手法として、**線形結合（Linear Combination）**、**Reciprocal Rank Fusion（RRF）**、**Learning to Rank（LTR）**の3つを、MS MARCO・BEIR・TREC Robust04の複数タスクで評価しています。

結論として、RRF（k=60）はハイパーパラメータ調整不要で安定した性能を発揮するデフォルト推奨手法であり、訓練データが十分にある場合（>10,000クエリ）はLTRが上回ることを実証しました。

この記事は [Zenn記事: BM25×ベクトル検索のハイブリッド実装：RRFで検索精度を30%向上させる実践ガイド](https://zenn.dev/0h_n0/articles/f3d8b80351ae7b) の深掘りです。

## 情報源

- **arXiv ID**: 2210.11934
- **URL**: [arXiv:2210.11934](https://arxiv.org/abs/2210.11934)
- **著者**: Sebastian Bruch, Siyu Gai, Amir Ingber
- **発表年**: 2022年（2023年改訂）
- **分野**: Information Retrieval (cs.IR)

## 背景と動機（Background & Motivation）

デンス検索（Dense Retrieval）の台頭により、BM25等のスパース検索を単独で使う時代から、**複数の検索手法を組み合わせるハイブリッド検索**が標準的なアプローチとなりました。しかし、既存研究の多くは特定の融合関数を「なんとなく」選択しており、**融合関数間の体系的な比較**が欠けていました。

本論文が取り組む3つの問いは以下の通りです：

1. **RRFと線形結合のどちらが優れるか？** — 実務で最も頻繁に直面する選択
2. **スコア正規化はどの手法が最適か？** — 線形結合ではBM25スコア（0〜数十）とコサイン類似度（0〜1）のスケール差が問題になる
3. **訓練データがある場合、LTR（Learning to Rank）はどの程度有効か？** — 教師あり手法の実用性

## 主要な貢献（Key Contributions）

- **貢献1**: 3種類の融合関数（線形結合・RRF・LTR）をMS MARCO、BEIR、TREC Robust04の3ベンチマークで**同一条件下**で比較した初の体系的研究
- **貢献2**: RRFのkパラメータ感度分析（k=1〜1000）を実施し、k=20〜100の範囲で安定することを実証
- **貢献3**: 訓練データ量に応じた**融合手法選択の判断基準**を定量的に導出

## 技術的詳細（Technical Details）

### 融合関数の数式定義

#### 1. 線形結合（Convex Combination / Score-based Fusion）

2つの検索システムのスコアを重み付き加算で統合します：

$$
\text{Score}_{\text{hybrid}}(d, q) = \alpha \cdot \hat{s}_{\text{sparse}}(d, q) + (1 - \alpha) \cdot \hat{s}_{\text{dense}}(d, q)
$$

ここで、
- $\hat{s}_{\text{sparse}}$: 正規化後のスパース検索スコア
- $\hat{s}_{\text{dense}}$: 正規化後のデンス検索スコア
- $\alpha \in [0, 1]$: 混合重み（スパース検索の重要度）

**正規化手法の比較**: スコアの正規化にはMin-Max正規化が最良であることが実験で示されました：

$$
\hat{s}(d) = \frac{s(d) - s_{\min}}{s_{\max} - s_{\min}}
$$

正規化なしの場合、MS MARCOでMRR@10が33.6→28.9に**大幅低下**します。これはBM25スコア（0〜数十の範囲）がコサイン類似度（0〜1）を圧倒し、デンス検索の寄与が無視されるためです。

#### 2. Reciprocal Rank Fusion（RRF）

スコアの大きさを無視し、**順位のみ**で統合するランクベースの手法です：

$$
\text{RRF}(d) = \sum_{r \in R} \frac{1}{k + \text{rank}_r(d)}
$$

ここで、
- $R$: 検索システムの集合（例: BM25とDPRの2つ）
- $\text{rank}_r(d)$: 検索システム$r$における文書$d$の順位（1-indexed）
- $k$: 平滑化定数（Cormack et al., 2009で提案されたk=60がデフォルト）

**RRFの数学的性質**: k値が大きいほど順位間のスコア差が縮小し、均一な重み付けに近づきます。k=1では1位の文書が圧倒的に高スコアを得て、k→∞では全順位がほぼ等しい重みになります。

#### 3. Learning to Rank（LTR）

教師あり学習で融合を最適化するアプローチです：

$$
\hat{y} = f_\theta(\mathbf{x})
$$

ここで、
- $\mathbf{x}$: 特徴ベクトル（各検索システムのスコア、順位、文書統計量等）
- $f_\theta$: LambdaMARTモデル（LightGBMで実装）
- $\hat{y}$: 予測関連度スコア

**特徴量**: BM25スコア、デンス検索スコア、BM25順位、デンス順位、文書長など

### 検索システムの構成

| システム | 種別 | モデル |
|---------|------|--------|
| BM25 | スパース（語彙ベース） | Anserini/Pyserini |
| SPLADE | スパース（学習済み） | SPLADE++ |
| DPR | デンス | Facebook DPR |
| TAS-B | デンス | MS MARCO fine-tuned |
| ColBERT v2 | 遅延交互作用 | Stanford ColBERT v2 |

### 実装

```python
from typing import Protocol

class Retriever(Protocol):
    def retrieve(self, query: str, k: int) -> list[tuple[str, float]]:
        """クエリに対してtop-k文書を(doc_id, score)で返す"""
        ...

def reciprocal_rank_fusion(
    rankings: list[list[str]],
    k: int = 60,
) -> list[tuple[str, float]]:
    """複数のランク付きリストをRRFで統合する。

    Args:
        rankings: 各検索システムの文書IDリスト（順位順）
        k: 平滑化定数（デフォルト: 60）

    Returns:
        (doc_id, rrf_score)のリスト（スコア降順）
    """
    rrf_scores: dict[str, float] = {}

    for ranking in rankings:
        for rank, doc_id in enumerate(ranking, start=1):
            rrf_scores[doc_id] = rrf_scores.get(doc_id, 0.0) + 1.0 / (k + rank)

    return sorted(rrf_scores.items(), key=lambda x: x[1], reverse=True)


def linear_combination(
    sparse_scores: dict[str, float],
    dense_scores: dict[str, float],
    alpha: float = 0.5,
) -> list[tuple[str, float]]:
    """Min-Max正規化後のスコアを線形結合する。

    Args:
        sparse_scores: スパース検索の{doc_id: score}辞書
        dense_scores: デンス検索の{doc_id: score}辞書
        alpha: スパース検索の重み（0〜1）

    Returns:
        (doc_id, hybrid_score)のリスト（スコア降順）
    """
    def min_max_norm(scores: dict[str, float]) -> dict[str, float]:
        vals = list(scores.values())
        lo, hi = min(vals), max(vals)
        if hi == lo:
            return {k: 0.0 for k in scores}
        return {k: (v - lo) / (hi - lo) for k, v in scores.items()}

    s_norm = min_max_norm(sparse_scores)
    d_norm = min_max_norm(dense_scores)

    all_docs = set(s_norm) | set(d_norm)
    hybrid = {
        doc: alpha * s_norm.get(doc, 0.0) + (1 - alpha) * d_norm.get(doc, 0.0)
        for doc in all_docs
    }
    return sorted(hybrid.items(), key=lambda x: x[1], reverse=True)
```

## 実験結果（Results）

### MS MARCO Passage Retrieval

| 手法 | MRR@10 | Recall@1000 |
|------|--------|-------------|
| BM25単体 | 18.4 | 85.7 |
| DPR単体 | 31.1 | 95.0 |
| SPLADE単体 | 36.8 | 97.9 |
| BM25 + DPR（線形結合） | 33.6 | 96.5 |
| BM25 + DPR（RRF, k=60） | 34.2 | 96.8 |
| SPLADE + DPR（線形結合） | 38.4 | 98.1 |
| **SPLADE + DPR（RRF, k=60）** | **39.1** | **98.3** |

**注目ポイント**: SPLADE + DPRのRRF融合がMRR@10で39.1を達成し、全組み合わせで最高です。BM25単体から**+20.7ポイント**の改善は、ハイブリッド検索の有効性を端的に示しています。

### BEIR Zero-Shot評価

18データセットの平均NDCG@10：

| 手法 | 平均NDCG@10 |
|------|------------|
| BM25 | 43.0 |
| TAS-B | 44.2 |
| SPLADE | 49.6 |
| BM25 + TAS-B（RRF） | 48.3 |
| BM25 + SPLADE（RRF） | 50.4 |
| **SPLADE + TAS-B（RRF）** | **52.1** |

BEIRはゼロショット（訓練データなし）評価であるため、**スコア分布が未知の設定**です。RRFがスコア正規化不要という特性により、ゼロショット環境で特に有効であることが確認されました。

### TREC Robust04 Document Retrieval

| 手法 | NDCG@20 | MAP |
|------|---------|-----|
| BM25単体 | 41.2 | 25.3 |
| DPR単体 | 38.9 | 24.1 |
| BM25 + DPR（線形結合, 最適α） | 45.1 | 28.6 |
| BM25 + DPR（RRF, k=60） | 44.7 | 28.1 |
| **LTR（BM25 + DPR特徴量）** | **47.2** | **30.1** |

**重要な発見**: 十分な訓練データ（249トピック、交差検証）がある場合、**LTRがRRFを+2.5ポイント上回り**ます。ただし、LTRにはラベル付きデータが必須であり、実務でのコスト対効果を考慮する必要があります。

### kパラメータの感度分析

| k値 | 特性 | MS MARCO MRR@10 |
|-----|------|----------------|
| k=1 | 攻撃的（1位に高スコア集中） | 33.8 |
| k=20 | やや攻撃的 | 34.0 |
| **k=60** | **デフォルト推奨** | **34.2** |
| k=100 | 保守的 | 34.1 |
| k=1000 | 超保守的（ランク平均に近い） | 33.5 |

k=20〜100の範囲でMRR@10の変動は0.2ポイント以内であり、**k=60はロバストな選択**です。

### スコア正規化手法の比較

| 正規化手法 | MS MARCO MRR@10 |
|-----------|----------------|
| 正規化なし | 28.9 |
| Sum正規化 | 32.8 |
| Z-score | 33.1 |
| **Min-Max** | **33.6** |

## 融合手法の使い分け判断基準

本論文の実験結果から導出される**実務向け判断基準**：

| シナリオ | 推奨手法 | 理由 |
|---------|---------|------|
| 訓練データなし | **RRF (k=60)** | チューニング不要、ゼロショットでロバスト |
| 少量の訓練データ（<1,000クエリ） | RRF or 交差検証付き線形結合 | αの最適化に十分なデータがない |
| 大量の訓練データ（>10,000クエリ） | **LTR (LambdaMART)** | 非線形組み合わせで性能最大化 |
| スコア分布が未知 | **RRF** | スコア正規化が不要 |
| スコア分布が既知で安定 | 線形結合（Min-Max正規化） | αの微調整で精度向上の余地あり |
| レイテンシ重視 | RRF or 線形結合 | 両者ともO(n)、LTRは推論コストが加算 |

### 補完性分析

ハイブリッド検索が有効な根本理由は、検索結果の**重複率の低さ**にあります：

- BM25のtop-100とDPRのtop-100の重複率: **約30%**
- SPLADEのtop-100とDPRのtop-100の重複率: **約45%**

重複が30%しかないということは、BM25が見つけてDPRが見逃す文書が70%も存在することを意味します。この補完関係が、融合による精度向上の源泉です。

## 実装のポイント（Implementation）

### 実装時の注意点

1. **線形結合では正規化が必須**: BM25スコアは非有界（文書により0〜数十）、コサイン類似度は[0, 1]の範囲。正規化なしではBM25が支配的になり、デンス検索の効果が消失する

2. **RRFは「検索されなかった文書」の処理**: 片方の検索システムで返されなかった文書のRRFスコアは、その検索システムからの寄与が0になる。これは自然なペナルティとして機能する

3. **SPLADEはBM25の上位互換**: スパースコンポーネントとしてSPLADE++を使えるなら、BM25よりも一貫して高い性能が得られる。ただしSPLADEはGPUが必要

4. **LTRにはLightGBMのLambdaMARTが推奨**: Pyseriniとの連携が容易で、特徴量エンジニアリングの自由度が高い

### パフォーマンス特性

- **RRF計算量**: O(n × m)、n=検索システム数、m=候補文書数。検索後の後処理であり、レイテンシへの影響は無視できる
- **線形結合**: O(m)、正規化計算を含む
- **LTR推論**: O(m × d × T)、d=特徴次元数、T=決定木数。LightGBMは高速だが、数万候補にはバッチ推論が必要

## 実運用への応用（Practical Applications）

Zenn記事で紹介されているQdrant/Elasticsearch/Weaviateでのハイブリッド検索実装に対して、本論文の知見は以下の判断根拠を提供します：

1. **RRF k=60はデフォルトとして正しい**: 本論文のk=20〜100範囲でのロバスト性分析が裏付け
2. **Elasticsearchのretriever構文（RRF）は理論的に正当**: スコア正規化不要の利点がBEIRゼロショットで実証済み
3. **Weaviateのalpha調整は線形結合の最適化に相当**: Min-Max正規化の上でαを0.3〜0.7の範囲でチューニングすべき
4. **本番データが十分にあるなら、LTRへの移行を検討**: NDCG@20で+2.5ポイントの改善が見込める

## Production Deployment Guide

### AWS実装パターン（コスト最適化重視）

**トラフィック量別の推奨構成**:

| 規模 | 月間リクエスト | 推奨構成 | 月額コスト | 主要サービス |
|------|--------------|---------|-----------|------------|
| **Small** | ~3,000 (100/日) | Serverless | $50-150 | Lambda + OpenSearch Serverless |
| **Medium** | ~30,000 (1,000/日) | Hybrid | $300-800 | Lambda + ECS Fargate + ElastiCache |
| **Large** | 300,000+ (10,000/日) | Container | $2,000-5,000 | EKS + Karpenter + EC2 Spot |

**Small構成の詳細** (月額$50-150):
- **Lambda**: 1GB RAM, 30秒タイムアウト ($20/月)
- **OpenSearch Serverless**: 2 OCU (検索+インデックス) ($70/月)
- **DynamoDB**: On-Demand ($10/月)
- **CloudWatch**: 基本監視 ($5/月)

**Medium構成の詳細** (月額$300-800):
- **ECS Fargate**: 0.5 vCPU, 1GB RAM × 2タスク ($120/月)
- **OpenSearch**: t3.small.search × 2ノード ($100/月)
- **ElastiCache Redis**: cache.t3.micro ($15/月)
- **Application Load Balancer**: ($20/月)

**Large構成の詳細** (月額$2,000-5,000):
- **EKS**: コントロールプレーン ($72/月)
- **EC2 Spot Instances**: r6g.xlarge × 2-4台 (平均$300/月)
- **OpenSearch**: r6g.large.search × 3ノード ($800/月)
- **Karpenter**: 自動スケーリング（追加コストなし）

**コスト削減テクニック**:
- Spot Instances使用で最大90%削減（Karpenter自動管理）
- Reserved Instances購入で最大72%削減（1年コミット）
- OpenSearch Serverlessはアイドル時自動スケールダウン
- ElastiCacheでRRF結果をキャッシュし、同一クエリの再計算を防止

**コスト試算の注意事項**:
- 上記は2026年2月時点のAWS ap-northeast-1（東京）リージョン料金に基づく概算値です
- 実際のコストはトラフィックパターン、リージョン、バースト使用量により変動します
- 最新料金は [AWS料金計算ツール](https://calculator.aws/) で確認してください

### Terraformインフラコード

**Small構成 (Serverless): Lambda + OpenSearch Serverless**

```hcl
# --- OpenSearch Serverless（ハイブリッド検索用） ---
resource "aws_opensearchserverless_collection" "hybrid_search" {
  name = "hybrid-search"
  type = "SEARCH"
}

resource "aws_opensearchserverless_security_policy" "encryption" {
  name = "hybrid-search-encryption"
  type = "encryption"

  policy = jsonencode({
    Rules = [{
      ResourceType = "collection"
      Resource     = ["collection/hybrid-search"]
    }]
    AWSOwnedKey = true
  })
}

# --- IAMロール（最小権限） ---
resource "aws_iam_role" "lambda_search" {
  name = "lambda-hybrid-search-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = { Service = "lambda.amazonaws.com" }
    }]
  })
}

resource "aws_iam_role_policy" "opensearch_access" {
  role = aws_iam_role.lambda_search.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect   = "Allow"
      Action   = ["aoss:APIAccessAll"]
      Resource = aws_opensearchserverless_collection.hybrid_search.arn
    }]
  })
}

# --- Lambda関数（RRF融合ロジック） ---
resource "aws_lambda_function" "hybrid_search" {
  filename      = "lambda.zip"
  function_name = "hybrid-search-rrf"
  role          = aws_iam_role.lambda_search.arn
  handler       = "index.handler"
  runtime       = "python3.12"
  timeout       = 30
  memory_size   = 1024

  environment {
    variables = {
      OPENSEARCH_ENDPOINT = aws_opensearchserverless_collection.hybrid_search.collection_endpoint
      RRF_K               = "60"
    }
  }
}

# --- CloudWatch アラーム ---
resource "aws_cloudwatch_metric_alarm" "search_latency" {
  alarm_name          = "hybrid-search-latency-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "Duration"
  namespace           = "AWS/Lambda"
  period              = 300
  statistic           = "p99"
  threshold           = 5000
  alarm_description   = "ハイブリッド検索のP99レイテンシが5秒超過"

  dimensions = {
    FunctionName = aws_lambda_function.hybrid_search.function_name
  }
}
```

**Large構成 (Container): EKS + OpenSearch**

```hcl
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 20.0"

  cluster_name    = "hybrid-search-cluster"
  cluster_version = "1.31"

  vpc_id     = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnets

  cluster_endpoint_public_access = true
  enable_cluster_creator_admin_permissions = true
}

resource "kubectl_manifest" "karpenter_provisioner" {
  yaml_body = <<-YAML
    apiVersion: karpenter.sh/v1alpha5
    kind: Provisioner
    metadata:
      name: search-nodes
    spec:
      requirements:
        - key: karpenter.sh/capacity-type
          operator: In
          values: ["spot"]
        - key: node.kubernetes.io/instance-type
          operator: In
          values: ["r6g.xlarge", "r6g.2xlarge"]
      limits:
        resources:
          cpu: "32"
          memory: "128Gi"
      ttlSecondsAfterEmpty: 30
  YAML
}

resource "aws_budgets_budget" "search_monthly" {
  name         = "hybrid-search-monthly"
  budget_type  = "COST"
  limit_amount = "5000"
  limit_unit   = "USD"
  time_unit    = "MONTHLY"

  notification {
    comparison_operator        = "GREATER_THAN"
    threshold                  = 80
    threshold_type             = "PERCENTAGE"
    notification_type          = "ACTUAL"
    subscriber_email_addresses = ["ops@example.com"]
  }
}
```

### セキュリティベストプラクティス

- **IAMロール**: 最小権限の原則（OpenSearch APIアクセスのみ許可）
- **ネットワーク**: VPCエンドポイント経由でOpenSearchにアクセス
- **暗号化**: OpenSearch Serverlessは自動暗号化、S3/DynamoDBはKMS暗号化
- **シークレット管理**: AWS Secrets Manager使用
- **監査**: CloudTrail有効化

### 運用・監視設定

**CloudWatch Logs Insights クエリ**:
```sql
-- RRF融合のレイテンシ分布
fields @timestamp, rrf_latency_ms, bm25_latency_ms, dense_latency_ms
| stats pct(rrf_latency_ms, 95) as p95_rrf,
        pct(bm25_latency_ms, 95) as p95_bm25,
        pct(dense_latency_ms, 95) as p95_dense
  by bin(5m)

-- 検索精度モニタリング（NDCG推定）
fields @timestamp, query_id, ndcg_at_10
| stats avg(ndcg_at_10) as avg_ndcg by bin(1h)
| filter avg_ndcg < 0.5
```

**CloudWatch アラーム設定**:
```python
import boto3

cloudwatch = boto3.client('cloudwatch')

cloudwatch.put_metric_alarm(
    AlarmName='hybrid-search-latency-spike',
    ComparisonOperator='GreaterThanThreshold',
    EvaluationPeriods=2,
    MetricName='Duration',
    Namespace='AWS/Lambda',
    Period=300,
    Statistic='p99',
    Threshold=5000,
    AlarmDescription='ハイブリッド検索P99レイテンシ異常'
)
```

### コスト最適化チェックリスト

**アーキテクチャ選択**:
- [ ] ~100 req/日 → Lambda + OpenSearch Serverless - $50-150/月
- [ ] ~1000 req/日 → ECS Fargate + OpenSearch Managed - $300-800/月
- [ ] 10000+ req/日 → EKS + Spot + OpenSearch Dedicated - $2,000-5,000/月

**リソース最適化**:
- [ ] EC2: Spot Instances優先（最大90%削減）
- [ ] Reserved Instances: 1年コミットで72%削減（OpenSearch）
- [ ] Lambda: メモリサイズ最適化（1024MB推奨）
- [ ] OpenSearch: UltraWarm（アクセス頻度が低いインデックス）

**検索パイプライン最適化**:
- [ ] BM25とデンス検索を並列実行（レイテンシ50%削減）
- [ ] RRF結果キャッシュ（ElastiCache、TTL 5分）
- [ ] 候補文書数制限（top-100で十分、top-1000は過剰）

**監視・アラート**:
- [ ] CloudWatch: P95/P99レイテンシ監視
- [ ] AWS Budgets: 月額予算設定
- [ ] Cost Anomaly Detection: 自動異常検知

## 関連研究（Related Work）

- **Cormack et al. (2009)**: RRFの原論文。k=60の提案とCondorcet法との比較でRRFの優位性を実証。本論文はこの知見を大規模ベンチマークで再検証している
- **SPLADE (Formal et al., 2021)**: BERTベースのスパース検索モデル。本論文ではBM25の上位互換として位置づけられ、ハイブリッド融合のスパースコンポーネントとしての有効性を示した
- **DPR (Karpukhin et al., 2020)**: Bi-encoderアーキテクチャによるデンス検索。BM25との補完性が高く、top-100の重複率がわずか30%である点が本論文で定量化された

## まとめと今後の展望

本論文は、ハイブリッド検索の融合関数選択に**定量的根拠**を提供した重要な研究です。

**主要な成果**:
- RRF（k=60）は調整不要で安定した性能を発揮する**最安全な選択**
- 線形結合はMin-Max正規化が必須、αの最適値はデータセット依存（0.3〜0.7）
- LTRは訓練データが十分ならRRFを超えるが、実務コストとのトレードオフあり

**実務への示唆**: Zenn記事で紹介されているRRF k=60は本論文の広範な実験により裏付けられており、プロダクション環境でのデフォルト設定として**理論的にも実験的にも正当**です。

## 参考文献

- **arXiv**: [https://arxiv.org/abs/2210.11934](https://arxiv.org/abs/2210.11934)
- **Pyserini (BM25実装)**: [https://github.com/castorini/pyserini](https://github.com/castorini/pyserini)
- **Related Zenn article**: [https://zenn.dev/0h_n0/articles/f3d8b80351ae7b](https://zenn.dev/0h_n0/articles/f3d8b80351ae7b)
