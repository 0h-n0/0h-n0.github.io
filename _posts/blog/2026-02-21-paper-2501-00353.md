---
layout: post
title: "サーベイ解説: Agentic RAG — エージェント型検索拡張生成の体系的分類と実装フレームワーク"
description: "Agentic RAGのアーキテクチャパターンをSingle-Agent/Multi-Agentに体系分類し、LangGraph等の実装フレームワークを比較するサーベイ論文です"
categories: [blog, paper, arxiv]
tags: [RAG, agentic-RAG, LangGraph, CRAG, Self-RAG, multi-agent, survey]
date: 2026-02-21 11:00:00 +0900
source_type: arxiv
arxiv_id: "2501.00353"
source_url: https://arxiv.org/abs/2501.00353
zenn_article: 32bc8fd091100d
zenn_url: https://zenn.dev/0h_n0/articles/32bc8fd091100d
math: true
mermaid: true
target_audience: "修士学生レベル"
---

## 論文概要（Abstract）

本論文は、静的なRAGパイプラインから自律的なAIエージェントがリトリーバルと生成を動的にオーケストレーションするAgentic RAGへの進化を体系的にサーベイした研究です。アーキテクチャの複雑性に基づく新しい分類体系（taxonomy）を提示し、Single-Agent（Corrective RAG、Self-RAG、Adaptive RAG、ReActベース）からMulti-Agent（階層型、ネットワーク型、Corrective Multi-Agent）までのパターンを整理しています。さらに、LangGraph、LlamaIndex、AutoGen、CrewAI等の実装フレームワークを比較し、ヘルスケア・法律・金融等のドメイン応用も網羅しています。

この記事は [Zenn記事: LangGraph×Claude Sonnet 4.6エージェント型RAGの精度評価と最適化](https://zenn.dev/0h_n0/articles/32bc8fd091100d) の深掘りです。

## 情報源

- **arXiv ID**: 2501.00353
- **URL**: [https://arxiv.org/abs/2501.00353](https://arxiv.org/abs/2501.00353)
- **著者**: Aditi Singh, Abul Ehtesham, Saket Kumar, Tala Talaei Khoei
- **発表年**: 2025
- **分野**: cs.AI, cs.CL

## 背景と動機（Background & Motivation）

従来のRAGは「検索→生成」の静的パイプラインであり、3つの根本的な限界を持っています。第一に、固定的な検索戦略がクエリの複雑さに適応できません。第二に、1パスの検索では多面的なクエリに必要な情報を全て取得できません。第三に、検索結果の品質を検証・修正するメカニズムがありません。

Agentic RAGは、自律的なAIエージェントをRAGパイプラインに統合することで、これらの限界を克服します。エージェントは多段階ワークフローの計画、フィードバックに基づく適応、多様なツールの使用、出力の反復的改善を行い、複雑な推論を可能にします。

## 主要な貢献（Key Contributions）

- **新しい分類体系**: アーキテクチャの複雑性に基づき、Single-Agent（4パターン）とMulti-Agent（4パターン）に体系分類
- **実装フレームワーク比較**: LangGraph、LlamaIndex、AutoGen、CrewAI、Haystack、DSPyの設計思想と特徴を比較
- **ドメイン応用分析**: ヘルスケア、法律、金融、教育、コーディング支援でのAgentic RAG活用を分析
- **課題と将来展望**: スケーラビリティ、バイアス、プライバシー等の課題と10の研究方向を提示

## 技術的詳細（Technical Details）

### RAGの進化: 静的からエージェント型へ

本論文はRAGの進化を4段階で整理しています。

| システム種別 | 検索方式 | 適応性 | 多段階推論 |
|------------|---------|-------|-----------|
| Naive RAG | 1パス検索 | なし | 不可 |
| Advanced RAG | 前/後処理付き検索 | 限定的 | 不可 |
| Modular RAG | プラガブルモジュール | 部分的 | 限定的 |
| **Agentic RAG** | **動的・反復的** | **完全** | **可能** |

### Agentic RAGのコアコンポーネント

エージェント型RAGは5つのコアコンポーネントで構成されます。

1. **オーケストレータ/プランナー**: 複雑なクエリをサブタスクに分解し、検索戦略を選択
2. **リトリーバーエージェント**: 異なる知識源に特化した検索エージェント
3. **クリティック/リフレクター**: 検索結果と生成応答を評価し、必要に応じて再検索をトリガー
4. **ツールインテグレータ**: API、計算機、コード実行、Web検索に接続
5. **メモリモジュール**: 短期（コンテキストウィンドウ）、長期（ベクトルDB）、エピソード（過去のインタラクション）

### Single-Agent RAGパターン

#### Corrective RAG (CRAG)

リトリーバル評価器が検索文書の関連性を評価し、品質に応じて3つのアクションを実行します。

```python
def corrective_rag(query: str, retriever, evaluator, web_search) -> str:
    """Corrective RAGの実行フロー"""
    # ステップ1: 検索
    passages = retriever.retrieve(query, top_k=10)

    # ステップ2: 評価
    score = evaluator.evaluate(query, passages)

    # ステップ3: アクション選択
    if score > UPPER_THRESHOLD:       # CORRECT
        knowledge = refine(passages)  # 関連部分のみ抽出
    elif score < LOWER_THRESHOLD:     # INCORRECT
        knowledge = web_search(query) # Web検索にフォールバック
    else:                             # AMBIGUOUS
        knowledge = combine(refine(passages), web_search(query))

    # ステップ4: 生成
    return generate(query, knowledge)
```

Zenn記事のDocument Gradingノードは、このCRAGの評価メカニズムをLangGraphのグラフ構造で実装したものです。

#### Self-Reflective RAG (Self-RAG)

反省トークン（`[Retrieve]`, `[IsREL]`, `[IsSUP]`, `[IsUSE]`）により、モデルが検索・生成・批評を統合的に実行します。Self-RAG 13BはPopQAでChatGPT+RAGを+26.9ポイント上回り、FactScoreで76.4を達成しました。

Zenn記事のSelf-Reflective RAGフローは、Self-RAGの設計思想をファインチューニング不要でLangGraph上に実装するアプローチです。

#### Adaptive RAG

クエリの複雑さに応じて検索戦略を動的に切り替えます。

- **Level 0**: 検索不要（単純な事実質問、LLMの内部知識で回答可能）
- **Level 1**: 1段階検索（標準的なRAGで十分）
- **Level 2**: 多段階検索（複雑な推論が必要、複数回の検索を実行）

Zenn記事のeffortパラメータ最適化（`medium`/`high`の使い分け）は、Adaptive RAGの精神をClaude Sonnet 4.6の推論深度制御で実現するものです。

#### ReActベースRAG

Thought → Action → Observationのループで検索と推論を交互に実行します。HotpotQA、FEVERでChain-of-Thought単体を上回る性能を示しています。

### Multi-Agent RAGパターン

#### 階層型Multi-Agent

オーケストレータエージェントがクエリを分解し、専門サブエージェントが並列に処理します。

```
1. オーケストレータ: 複雑なクエリを受信
2. N個のサブクエリに分解
3. N個のリトリーバーエージェントが並列検索
4. アグリゲータが結果を統合
5. ジェネレータが最終回答を合成
```

#### パターン比較表

| パターン | エージェント数 | 反省機能 | 多段階 | 並列性 | 複雑度 |
|---------|-------------|---------|-------|-------|-------|
| Corrective RAG | Single | 検索評価 | 限定的 | なし | 低 |
| Self-RAG | Single | トークンレベル | あり | なし | 中 |
| Adaptive RAG | Single | クエリ分類 | あり | なし | 中 |
| ReAct RAG | Single | Action-Observation | あり | なし | 中 |
| 階層型Multi-Agent | Multi | オーケストレータ | あり | あり | 高 |
| Corrective Multi-Agent | Multi | 専用クリティック | あり | 部分的 | 高 |

### 実装フレームワーク比較

| フレームワーク | 設計思想 | 強み | Zenn記事との関連 |
|--------------|---------|------|----------------|
| **LangGraph** | 状態機械ベース | 条件付きエッジ、ループのサポート | **記事で使用** |
| LlamaIndex | エージェントランナー | 組み込みツール、SubQuestion分解 | 代替候補 |
| AutoGen | マルチエージェント会話 | Human-in-the-loop | 会話型タスク向け |
| CrewAI | ロールベース | タスク委任、並列実行 | チーム協調向け |
| Haystack | パイプライン型 | 本番REST API対応 | プロダクション向け |
| DSPy | プログラマティック | プロンプト自動最適化 | 学習データがある場合 |

LangGraphが選ばれる理由は、**条件付きエッジによる動的ルーティング**と**ループのネイティブサポート**です。Corrective RAGのクエリ書き換え→再検索ループや、Self-Reflective RAGの生成→検証→再生成ループを自然に表現できます。

### メモリアーキテクチャ

Agentic RAGでは4種類のメモリが重要です。

| メモリ種別 | ストレージ | 寿命 | 用途 |
|-----------|----------|------|-----|
| 作業記憶 | コンテキストウィンドウ | 1推論 | 現在のクエリ処理 |
| 短期記憶 | 会話バッファ | セッション | マルチターン対話 |
| 長期記憶 | ベクトルDB | 永続 | セッション間知識 |
| エピソード記憶 | 構造化ログ | 永続 | 過去のインタラクションから学習 |

Zenn記事の`GraphState`（`retry_count`, `grade_score`, `is_hallucination`）は作業記憶の実装に相当します。

### 評価指標とベンチマーク

本論文はAgentic RAG固有の評価指標を整理しています。

**従来のRAG指標**: Precision@K、Recall@K、MRR、NDCG（検索）、BLEU/ROUGE/BERTScore/FactScore（生成）

**Agentic固有の指標**:
- **タスク完了率**: エージェントが割り当てられたタスクを完了できたか
- **ツール呼び出し精度**: 正しいツールが選択・実行されたか
- **反復効率**: 何回の検索サイクルが必要だったか
- **ハルシネーション率**: 検索文書に支持されない主張の割合

**評価フレームワーク**: RAGAS（エンドツーエンド評価）、TruLens（フィードバック関数）、ARES（ファインチューニング型分類器）

## 実装のポイント（Implementation）

**アーキテクチャ選択の判断基準**: タスクの複雑さとレイテンシ要件で決定します。単純なQAにはCorrective RAG（低コスト・低レイテンシ）、正確性が最重要な場合はSelf-RAG（高精度・高コスト）、複数ドメインの統合が必要ならMulti-Agent（最高の柔軟性・最大のコスト）が適切です。

**スケーラビリティの課題**: Multi-Agentシステムはエージェント間の調整でレイテンシが増加します。並列検索で改善可能ですが、インフラコストが増大します。トークン予算管理も重要で、長いコンテキストウィンドウは高コストです。

**ハルシネーション対策**: 検索ありでもLLMが文脈を無視して生成する場合があります。Self-RAGの反省トークンやCRAGの評価器で部分的に軽減できますが、完全な排除は未解決問題です。

**プライバシーとセキュリティ**: 機密データベースからの検索にはアクセス制御が必要です。悪意ある検索コンテンツによるプロンプトインジェクション攻撃、プライベート文書のインデキシングによるPII漏洩リスクにも注意が必要です。

## 実運用への応用（Practical Applications）

Zenn記事のLangGraph実装は、本サーベイの分類ではSingle-Agent Corrective RAG + Self-Reflective RAGのハイブリッドに位置付けられます。具体的には:

- **Document Grading**: CRAGの検索評価メカニズム
- **Query Rewriting**: Adaptive RAGのクエリ最適化
- **Hallucination Check**: Self-RAGの`[IsSUP]`トークンに相当
- **effortパラメータ最適化**: Adaptive RAGの複雑さ判定の変形

この組み合わせにより、Zenn記事の実装はFaithfulness 0.91、ハルシネーション率2.3%という本番運用に耐える品質を達成しています。

## 関連研究（Related Work）

- **Self-RAG (2310.11511)**: 反省トークンによる自己批評型RAG。本サーベイではSingle-Agent Self-Reflective RAGパターンとして分類
- **Corrective RAG (2401.15884)**: 検索品質評価+Web検索フォールバック。Single-Agent Corrective RAGパターン
- **Adaptive-RAG (2404.16130)**: クエリ複雑さに基づく検索戦略切り替え。Single-Agent Adaptive RAGパターン
- **MetaGPT (2308.00352)**: SOP駆動のMulti-Agent協調フレームワーク。Multi-Agent階層型パターンの代表例

## まとめと今後の展望

本サーベイはAgentic RAGを体系的に分類し、実装フレームワークの選択からドメイン応用までの包括的な見取り図を提供しています。今後の方向性として、エージェント間調整プロトコルの形式検証、マルチモーダルAgentic RAG（テキスト+画像+音声）、エッジデバイスでの軽量Agentic RAG、そして信頼性保証のための形式的手法が挙げられています。

特に、Zenn記事で実装されているLangGraphベースのアプローチは、本サーベイの分類における「Production-Ready Single-Agent Hybrid」の好例であり、Corrective RAGとSelf-Reflective RAGの利点を組み合わせた実践的な設計です。

## 参考文献

- **arXiv**: [https://arxiv.org/abs/2501.00353](https://arxiv.org/abs/2501.00353)
- **Related Zenn article**: [https://zenn.dev/0h_n0/articles/32bc8fd091100d](https://zenn.dev/0h_n0/articles/32bc8fd091100d)
